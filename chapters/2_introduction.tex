\documentclass[../main]{subfiles}
\begin{document}

\chapter{Introduction}
\label{ch:introduction}
Software testing is a critical part in the software engineering process. 
It is a standardized in the industry and is used for quality assurance\cite{ISOtesting}. 
Software testing can detect software bugs during the development process and can also serve for regression purposes\cite{Bertolino2007SoftwareDreams}. 
During the software testing process developers write automated tests called unit tests. 
These tests can be run by testing frameworks such as JUnit and TestNG\cite{JUnit, TestNG}.
Monitoring the quality of test code has shown that tests with lower quality leads to more defect-prone production code\cite{Spadini2018OnQuality}. 
Research has also found that if the production code grows, the test code grows along with it\cite{Zaidman2008MiningCode}. 
Quality control on test suites is therefore important as the maintenance on tests can be difficult and generates risks if done incorrectly\cite{Horvath2015TestMetrics}.
\newline
The growing complexity and size of code bases consequently lead to incomprehensible tests.
As a result test bugs can occur. 
A test bug is a test that fail even tough the program is correct(\textit{false positive}). 
Another bug, which is even worse, are tests that do not fail when the program is not working as desired(\textit{false negative}).
The \textit{false negative} is a problem when breaking changes are not detected by the test suite.
\newline
To solve this issue we can measure the fault detecting capability of a test suite, this is called the test suite effectiveness.
Test suite effectiveness is measured by the number of faulty versions of a \acrfull{sut} that are detected by a test suite.
Real faults are unknown in advance, we can use mutation testing as a proxy measurement. 
Existing research has found statistically significant evidence which correlates mutant detection with real fault detection\cite{Just2014AreTesting}.
\newline
Mutation testing tools create small faulty versions of the program.
The test suite is then run to verify if these faults are detected.
These faults are called mutants and are created by mutators.
Mutators mutate specific expressions or statements in the source code. 
To prevent changing the overall functionality of the program, mutants are represented as very small changes\cite{Lipton1978HintsProgrammer}.
\newline
After all the mutants are executed the mutation score can be calculated. 
The mutation score is the percentage of mutants killed divided by the total amount of mutants executed.
If a large amount of mutants survives, it might be an indication that the quality of the test suite is poor as programming errors remain undetected.
Mutation testing has considerable drawbacks\cite{Pizzoleto2019}, such as the equivalent mutant problem and being resource expensive.

\section{Problem statement}
Mutation testing requires a significant amount of computational resources\cite{Kintis2016EffectiveMutation}. 
The high cost requirement is often a barrier for adopting mutation testing \cite{Pizzoleto2019}.
A lot of techniques and methods have been developed to improve the performance, however, most of these approaches are not as effective as mutation testing a full set of mutants\cite{Pizzoleto2019,Yao2014}. 
\newline
A technique to reduce the number of mutants or the number of test case executions is mutation clustering.
Mutation clustering aims to reduce the amount of mutants to be executed by clustering mutants\cite{Ma2016,Yu2019PossibilityScope}.
The clustering of mutants has been researched with promising results\cite{Ji2009,Wilinski2015,Ma2016}. For example Ma et al., \cite{Ma2016} clustered the mutants for expressions. 
However in their paper they indicate that the choosing expressions as the domain of their cluster is a limitation.
A recurring problem in the research of mutation clustering is to determine the means of domains as the centre of a cluster\cite{Ji2009,Wilinski2015,Ma2016,Wei2021SpectralTesting}.
\newline
To reduce the cost of mutation testing, we try to find a solution that can cluster mutants while maintaining the accuracy of the same complete set of mutants. 
Our goal is to cluster any mutant that is generated within the Java programming language.
This research aims to remove the scoping limitations present in existing research.
There should be no requirements for which mutants can be clustered.
We do this with two different techniques: qualitative and quantitative.
We devise a white and black box approach for clustering mutants.
Our white box approach contains a qualitative analysis on mutants and a methodology to cluster them.
The black box approach makes use of a machine learning model to cluster mutants.
We structure our research on the following research questions:
\newline
\textbf{Research Question 1}: What set of characteristics can we identify for clustering generated mutants to reduce the amount executed, while maintaining effectiveness?
\newline
\textbf{Research Question 1.1}: How do the existing mutation testing tools for Java compare to each other?
\newline
\textbf{Research Question 2}: How can we train a machine learning model to recognize and cluster generated mutants to reduce the amount executed, while maintaining effectiveness?
\newline
We start with comparing existing mutation testing tools. 
We will use the existing literature as a starting point and research what would be the best tool to use for this thesis.
\newline
After we have selected a tool we will research existing clustering techniques.
Based on the results of this research we select and implement a clustering algorithm that will cluster one ore more characteristics of the mutants. 
We will randomly select on mutant per of each cluster to be executed by the mutation tooling.
We will then compare the mutation score of the clustered mutants with the mutation score of a full set of mutants.
\newline
To answer our second research question we will train a machine learning model to cluster mutants.
We can then repeat the comparison we did for research question one. 
\newline
We want to see how the algorithm/model performs on big and small projects.
These project must also require a test suite.
\newline
We chose to focus on projects that use Java as main programming language because it is one of the most popular languages\cite{Tiobe}.

\section{Contributions}
Our research makes the following contributions:
\begin{enumerate}
 \item A white box methodology to cluster generated mutants based on chosen characteristics to reduce the cost of mutation testing.
  \item A black box methodology to cluster generated mutants based on chosen characteristics to reduce the cost of mutation testing.
 \item A \acrfull{poc} which implements the qualitative methodology chosen and elaborated within the thesis.
 \item A \acrfull{poc} which implements the quantitative approach to cluster mutants and is elaborated within the thesis. 
\end{enumerate}

\section{Outline}
In Chapter~\ref{ch:background} we describe the background information of this thesis. 
Chapter \ref{ch:mutation-tool} compares the different mutation testing tools to decide on a tool to use for this research.
In chapter \ref{ch:reserach_question1} we identify characteristics to represent mutants and design an experiment to cluster them.
In chapter \ref{ch:reserach_question2} we select a machine learning model and design an experiment to cluster mutants with this model.
Results are shown in Chapters \ref{ch:results_rq1} and \ref{ch:results_rq2} for the experiments described in Chapters \ref{ch:reserach_question1} and \ref{ch:reserach_question2} respectively. 
The results are then discussed in Chapter~\ref{ch:discussion}.
\newline
Chapter~\ref{ch:related_work}, contains the work related to this thesis.
Finally, we present our concluding remarks in Chapter~\ref{ch:conclusion} together with future work.

\end{document}