\documentclass[../main]{subfiles}
\begin{document}

\chapter{Introduction}
\label{ch:introduction}
Software testing is a critical part in the software engineering process. It is widely used and accepted in the industry for quality assurance. 
Software testing can detect software bugs during the development process and can also serve for regression purposes\cite{Bertolino2007SoftwareDreams}. 
During the software testing process developers write automated tests called unit tests. 
These tests can be run by testing frameworks such as JUnit and TestNG\cite{JUnit, TestNG}.
Monitoring the quality of test code has shown that tests with lower quality leads to more defect-prone production code\cite{Spadini2018OnQuality}. 
Research has also shown that as the size of production code grows, the size of the test code grows along\cite{Zaidman2008MiningCode}. 
Quality control on test suites is therefore important as the maintenance on tests can be difficult and generate risks if done incorrectly\cite{Horvath2015TestMetrics}.
These risks are related to the growing complexity and size which consequently lead to incomprehensible tests. 
One of these risks is the occurrence of test bugs i.e., test that fail even tough the program is correct(\textit{false positive}). 
A different one, which is even worse, are tests that do not fail when the program is not working as desired(\textit{false negative}).
The \textit{false negative} is a problem when breaking changes or not detected by the test suite.
To solve this issue we can measure the fault detecting capability of a test suite i.e., test suite effectiveness.
\newline
Test suite effectiveness is measured by the number of faulty versions of a \acrfull{sut} that are detected by a test suite. 
Real faults are unknown in advance, we can use mutation testing as a proxy measurement. 
There is statistically significant evidence that mutant detection correlates with real fault detection\cite{Just2014AreTesting}.
\newline
Mutation testing tools generate faulty versions of the program and then run the tests to determine
if the fault was detected. These faults, called mutants, are created by so-called mutators which mutate
specific statements in the source code. Each mutant represents a very small change to prevent changing
the overall functionality of the program\cite{Lipton1978HintsProgrammer}.
\newline
Mutation testing tools generate faulty versions of the program and then run the tests to determine if the fault was detected.
After all the mutants are executed the mutation score can be calculated. 
The mutation score is the percentage of mutants killed divided by the total amount of mutants executed.
If a large amount of mutants survives, it might be an indication that the test quality is insufficient as programming errors remain undetected.
Mutation testing has considerable drawbacks, such as the equivalent mutant problem and being resource expensive.

\section{Problem statement}
Mutation testing requires a significant amount of computational resources\cite{Kintis2016EffectiveMutation}. 
The high cost requirement is often a barrier for adopting mutation testing \cite{Pizzoleto2019}.
A lot of techniques and methods have been developed to improve the performance, however, most of these approaches are not as effective as mutation testing a full set of mutants\cite{Pizzoleto2019,Yao2014}. 
\newline
A technique to reduce the number of mutants or the number of test case executions is mutation clustering.
Mutation clustering aims to reduce the amount of mutants to be executed by clustering the mutants\cite{Ma2016,Yu2019PossibilityScope}.
Clustering is a technique used for the grouping of data, for pattern recognition and classification, based on some similar characteristics\cite{Alsabti1997}.
The clustering of mutants has been researched with promising results\cite{Ji2009,Wilinski2015,Ma2016}. For example Ma et al., \cite{Ma2016} clustered the mutants for expressions. 
However in their paper they indicate that the choosing expressions as the domain of their cluster is a limitation.
A recurring problem in the research of mutation clustering is to determine the means of domains as the centre of a cluster\cite{Ji2009,Wilinski2015,Ma2016,Wei2021SpectralTesting}.


\subsection{Research questions}
To reduce the cost of mutation testing, we try to find a solution that can cluster mutants while maintaining the accuracy of the same complete set of mutants. 
Our goal is to cluster any mutant that is generated.
We will do this with two different approaches.
Our first approach will be a qualitative approach and second a quantitative approach. 
We structure our research on the following research questions:
\newline
\textbf{Research Question 1}: What set of characteristics can we identify for clustering generated mutants to reduce the amount executed, while maintaining effectiveness?
\newline
\textbf{Research Question 1.1}: How do the existing mutation testing tools for Java compare to each other?
\newline
\textbf{Research Question 2}: How can we train a machine learning model to recognize and cluster generated mutants to reduce the amount executed, while maintaining effectiveness?

\subsection{Research method}
We start with comparing existing mutation testing tools. 
We will use the existing literature as a starting point and research what would be the best tool to use for this thesis.
\newline
After we have selected a tool we will research existing clustering techniques.
Based on the results of this research we select and implement one or more clustering algorithm that will cluster mutants. 
One or more mutants of each cluster will be executed by the mutation tooling.
We will then compare the mutation score of the clustered mutants with the mutation score of a full set of mutants.
\newline
To answer our second research question we will train a machine learning model to cluster mutants.
We can then repeat the comparison we did for research question one. 
\newline
We want to see how the algorithm/model performs on big and small projects.
These project must also require a test suite.
\newline
We focus on Java based projects because Java is one of the most popular programming languages\cite{Tiobe}.

\section{Contributions}
Our research makes the following contributions:
\begin{enumerate}
 \item A methodology to cluster generated mutants based on chosen characteristics to reduce the cost of mutation testing.
 \item A \acrfull{poc} which implements the qualitative methodology chosen and elaborated within the thesis.
 \item A \acrfull{poc} which implements the quantitative approach to cluster mutants. 
\end{enumerate}

\section{Outline}
In Chapter~\ref{ch:background} we describe the background of this thesis. 
\todo{finish this at the end}
Chapter~\ref{ch:research} describes ... 
Results are shown in Chapter~\ref{ch:results} and discussed in Chapter~\ref{ch:discussion}. Chapter~\ref{ch:related_work}, contains the work related to this thesis.
Finally, we present our concluding remarks in Chapter~\ref{ch:conclusion} together with future work.

\end{document}