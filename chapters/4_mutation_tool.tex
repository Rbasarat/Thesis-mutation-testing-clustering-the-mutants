\documentclass[../main]{subfiles}
\begin{document}

\chapter{Mutation testing tools}
\label{ch:mutation-tool}
To cluster mutants we need to select a tool that generate mutants and executes mutants.
Such tools are called mutation testing tools.
Our goal is to find the tool that generates the most amount of mutants. 
\newline
First, we review existing literature. 
Second, we extend the comparison by adding information about the current state of the tools.
With the combination of the information gathered we make a decision on what tool to use for this thesis.

\section{State of the art documented}
\label{ch:tooling-literature}
The literature used several criteria for comparing mutation testing tools for Java:
\begin{itemize}
  \item Execution time of each tool.
  \item The cost as the number of test cases that needs to be generated and the the number of equivalent mutants that would have to be inspected.
  \item Effectiveness of the mutation adequate test suite of each tool. Every test of the suite adds to the effectiveness score. If a test is removed less than 100\% effectiveness can be achieved. To evaluate the effectiveness of each tool's mutation adequate test suite, a cross-testing technique is applied. The adequate test suite per tool is run on the set of mutants generated by the other tools.
\end{itemize}
Kintis et al. analysed and compared the performance of PIT,  MuJava and Major\cite{Kintis2016AnalysingStudy}. 
They started out with performing a mini literature survey on mutation testing tools used in existing research on test effectiveness in Java. 
With a data set of twelve methods and six Java projects they evaluated each tool using a cross-testing technique.
As a result they found that the most effective mutation adequate test suite was from MuJava, followed by Major and PIT.
The score of the application cost was the inverse of the previous ranking: PIT generated the smallest set of equivalent mutants and required the least test cases.
During their research they also compared the different mutant operators the tools supported. 
An overview of mutant operators(also known as mutators) per tool was created. 
They compared the mutant operators and reported overlapping operators.
\newline
Marki and Lindstrom performed their research on the same three mutation testing tools.\cite{Marki2017MutationJava}. 
The same cross-testing technique used by Kintis et al., was applied for three small Java programs. 
These programs are popular programs used in testing literature.
They found that the mutation tools do not subsume each other. 
"one mutant subsumes a second mutant if every test that kills the first mutant is guaranteed also to kill the second \cite{Ammann2014EstablishingMutants}"
According to the research a ranking of the tools would be as follows; MuJava generated the strongest mutants followed by Major and PIT.
Furthermore they found that MuJava generated significantly more equivalent mutants\cite{Marki2017MutationJava}.
MuJava also had an execution time twice the amount of that of Major and PIT combined.
\newline
Laurent et al., introduced PIT+, a version of PIT with extended set of mutators\cite{Laurent2017AssessingPIT}.
They used the same tests suites that were generated by kintis et al., and combined these into an adequate test suite that would detect the combined set of mutants generated by PIT, MuJava and Major. 
They discovered that the set of mutants generated by PIT+ was stronger than the combined sets generated by the other three tools.
Fortunately the extended set of mutants used in PIT+ is now integrated in the PIT project\cite{pit+}.


\section{State of the art tools}
The literature is clear about how the mutation testing tools compare to each other.
However the most recent study is from 2017.
At the time of writing this thesis these studies are at least four years old. 
Some of the tools were updated or are still under active development\cite{pit-releases,Major}.
\newline
There are three candidate tools; Major, MuJava and PIT.
We extend the existing mutant operator comparison for these tools with the operators that have been added since the publishing date of the literature.
We also research the overlap for the new mutant operators.
Table \ref{tab:mutators-current} shows the mutant operators that were developed after the publication of the literature. The amount of mutant operators for  MuJava and PIT have increased significantly while there were no new mutant operators for Major.
\begin{table}[htb]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\multicolumn{2}{|c|}{\textbf{ MuJava}}                           & \multicolumn{2}{|c|}{\textbf{PIT}}                      \\ \hline
IHD & Hiding variable deletion                                  & EM                    & Empty Returns                   \\ \hline
IHI & Hiding variable   insertion                               & FR                    & False Returns                   \\ \hline
IOD & Overriding method   deletion                              & NR                    & Null Returns                    \\ \hline
IOP & Overriding method   calling position change               & TR                    & True Returns                    \\ \hline
IOR & Overriding method   rename                                & PR                    & Primitive Returns               \\ \hline
ISI & Super keyword insertion                                   & ER                    & Experimental Switch             \\ \hline
ISD & Super keyword deletion                                    & BI                    & Big Integer                     \\ \hline
IPC & Explicit call to a   parentâ€™s constructor deletion        & NRC                   & Naked Receiver                  \\ \hline
PNC & New method call with   child class type                   & N                     & Negation                        \\ \hline
PMD & Member variable   declaration with parent class type      & AOR                   & Arithmic Operator Replacement   \\ \hline
PPD & Parameter variable   declaration with child class type    & AOD                   & Arithmic Operator Deletion      \\ \hline
PCI & Type cast operator   insertion                            & CR                    & Constant replacement            \\ \hline
PCC & Cast type change                                          & BO                    & Bitwise Operator                \\ \hline
PCD & Type cast operator   deletion                             & ROR                   & Relational Operator Replacement \\ \hline
PRV & Reference assignment   with other comparable variable     & UOI                   & Unary Operation Insertion       \\ \hline
OMR & Overloading method   contents replace                     & \multicolumn{1}{l|}{} &                                 \\ \hline
OMD & Overloading method   deletion                             & \multicolumn{1}{l|}{} &                                 \\ \hline
OAC & Arguments of   overloading method call change             & \multicolumn{1}{l|}{} &                                 \\ \hline
JTI & This keyword insertion                                    & \multicolumn{1}{l|}{} &                                 \\ \hline
JTD & This keyword deletion                                     & \multicolumn{1}{l|}{} &                                 \\ \hline
JSI & Static modifier   insertion                               & \multicolumn{1}{l|}{} &                                 \\ \hline
JSD & Static modifier   deletion                                & \multicolumn{1}{l|}{} &                                 \\ \hline
JID & Member variable   initialization deletion                 & \multicolumn{1}{l|}{} &                                 \\ \hline
JDC & Java-supported default   constructor deletion             & \multicolumn{1}{l|}{} &                                 \\ \hline
EOA & Reference assignment   and content assignment replacement & \multicolumn{1}{l|}{} &                                 \\ \hline
EOC & Reference comparison   and content comparison replacement & \multicolumn{1}{l|}{} &                                 \\ \hline
EAM & Acessor method change                                     & \multicolumn{1}{l|}{} &                                 \\ \hline
EMM & Modifier method change                                    & \multicolumn{1}{l|}{} &                                 \\ \hline
\end{tabular}
\caption{\label{tab:mutators-current}Current mutators supported.}
\end{table}
\newpage
Tools sometimes implement the same mutator differently, resulting in different mutant sets. Table \ref{tab:mutators-overlap} shows an overview over the relations between the mutators of MuJava and PIT. 
Some of the new mutators from the tools map to the already existing mutators of the other tools.
To get a complete overview we include the mutators that have been reviewed in the studies of Kintis et al., and Marki and Lindstrom. 


\begin{table}[htb]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\multicolumn{2}{|c|}{\textbf{ MuJava mutator}}      & \multicolumn{2}{c|}{\textbf{PIT mutator}}                         \\ \hline
AORB & Arithmetic Operator Replacement Binary      & \multirow{4}{*}{M}   & \multirow{4}{*}{Math}                      \\ \cline{1-2}
ASRS & Short-Cut Assignment   Operator Replacement &                      &                                            \\ \cline{1-2}
SOR  & Shift Operator   Replacement                &                      &                                            \\ \cline{1-2}
COR  & Conditional Operator   Replacement          &                      &                                            \\ \hline
AOIU & Arithmetic Operator   Insertion Unary       & \multirow{2}{*}{UOI} & \multirow{2}{*}{Unary Operation Insertion} \\ \cline{1-2}
AOIS & Arithmetic Operator   Insertion Short-cut   &                      &                                            \\ \hline
ODL  & Operator Deletion                           & AOD                  & Arithmic Operator   Deletion               \\ \hline
AODS & Arithmetic Operator   Deletion Short-cut    & RI                   & Remove Increments                          \\ \hline
ROR  & Relational Operator   Replacement           & CB                   & Conditionals Boundary                      \\ \hline
AORS & Arithmetic Operator   Replacement Short-Cut & I                    & Increments                                 \\ \hline
COD  & Conditional Operator   Deletion             & RC                   & Remove Conditionials                       \\ \hline

\end{tabular}
\caption{\label{tab:mutators-overlap}Overview of mutator overlaps between  MuJavav and PIT}
\end{table}
Next we try to generate mutants with all three tools. 
All of the sources that we used for generating mutants are build with the build tools Maven or Gradle. 
Marki and Lindstrom\cite{Marki2017MutationJava} mention that Major includes support for Maven, but it is not documented anywhere.
For this reason we can not generate mutants with Major.
Table \ref{tab:mutants-generated} shows the amount of mutants generated per project and per tool. The results show that in all of the cases PIT generates more mutants than MuJava. In some cases the difference is significant. This difference can partially be explained by the fact that MuJava does not support source projects with Java version 1.7 or higher\cite{mujava}. All the code that uses the of features from this version of Java and above resulted in an error during mutant generation.

\begin{table}[htb]
\centering
\begin{tabular}{|l|l|c|c|c|}
\hline
                                & \textbf{version} & \textbf{\begin{tabular}[c]{@{}c@{}}LOC\\ (Lines of code)\end{tabular}} & \multicolumn{1}{l|}{\textbf{MuJava}} & \multicolumn{1}{l|}{\textbf{PIT}} \\ \hline
Commons-numbers.core            & 1.0-beta1        & 450                                                                    & 988                                  & 4384                              \\ \hline
Jodatime                        & 2.10.10          & 28811                                                                  & 52925                                & 112772                            \\ \hline
Zxing 3.4.1                     & 3.4.1            & 24792                                                                  & 65983                                & 161409                            \\ \hline
Google Auto Common              & 0.11.0           & 2338                                                                   & 20                                   & 5219                              \\ \hline
Google Auto Factory             & 1.0-beta9        & 1507                                                                   & 69                                   & 5832                              \\ \hline
Google Auto Value               & 1.7.5            & 7466                                                                   & 745                                  & 16746                             \\ \hline
Google Auto Service             & 1.0-rc6          & 750                                                                    & 0                                    & 475                               \\ \hline
ScribeJava-Core                 & 8.1.0            & 5709                                                                   & 1358                                 & 5746                              \\ \hline
Checkstyle                      & 8.41.1           & 38491                                                                  & 4529                                 & 100952                            \\ \hline
Fastjson                        & 1.2.75           & 43405                                                                  & 70577                                & 116188                            \\ \hline
Jfreechart                      & 1.5.3            & 91876                                                                  & 0                                    & 350741                            \\ \hline
Commons-lang                    & 3.12.0           & 29836                                                                  & 31145                                & 134764                            \\ \hline
Commons-codec                   & 1.15.0           & 9656                                                                   & 21719                                & 54804                            \\ \hline
Commons-text                   & 1.9.0             & 9781                                                                   & 10403                                & 48490                            \\ \hline
Commons-io                     & 2.8.0             & 13947                                                                  & 13245                                & 44631                            \\ \hline
Gson                           & 2.8.6             & 8078                                                                   & 9198                                 & 28485                            \\ \hline
Commons-cli                    & 1.4.0             & 2782                                                                   & 831                                  & 7193                             \\ \hline
Commons-csv                    & 1.8.0             & 1855                                                                   & 2081                                 & 6906                             \\ \hline
\end{tabular}
\caption{\label{tab:mutants-generated}Amount of mutants generated by MuJava and PIT}
\end{table}
\newpage
\section{Selecting mutation testing tool}
We studied literature on three different tools and extended the research with the current state of the art.
MuJava is not actively maintained and has not been updated in the last few years.
It does not support JUnit 4 and all versions of TestNG\cite{mujava}.
These are test engines and are crucial for executing tests.
MuJava also does not support source projects with java version 1.7 or higher\cite{mujava}.
Conforming to these requirements would reduce the set of projects we could use in or experiments.
\newline
While Major supports JUnit 4,
we did not succeed in generating mutants with this tool.
It would be too time consuming to customize all source projects to work with Major.
Furthermore there is not much documentation available for this tool.
\newline
PIT targets the industry, is actively maintained and is open source\cite{Kintis2016AnalysingStudy}.
It supports Maven, Gradle, has a \acrfull{cli} and has a faster execution time than the other tools.
For example PIT provides a plugin system in which you can inject your own code in various stages of mutation testing process\cite{pit}.
PIT also generated significantly more mutants in every project we have tested.
Based on the information presented in this chapter we decide that PIT is the best choice for generating and executing mutants.
\end{document}