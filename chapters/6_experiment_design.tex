\documentclass[../main]{subfiles}
\begin{document}
\chapter{Experiment design rq1}\todo{discuss how to split this with exp design for rq2}
In this chapter we will design an experiment to answer our first research question.
We hypothesise that we can cluster mutants with the identified set of characteristics 
while maintaining effectiveness when executing one mutant from each cluster that is in the majority of that cluster.
If a cluster contains ten mutants with eight mutants killed and two mutants survived, all the mutants that are killed are in the majority of that cluster.
Our goal is to achieve a mutation score that is as close as possible to the mutation score of a full set of executed mutants.
\newline
We will start with extracting the characteristics from the selected mutation testing tool. 
Next we select and implement a clustering algorithm for which we can cluster mutants.
We can then cluster the mutants and compare the results of the clusters with the results of the mutants. 

\section{Extracting characteristics}
To extract all the characteristics we identified we need to run PIT and configure it to generate all mutants that are possible within the tool. 
PIT works in phases, the first phase is the generation phase where mutants are generated.
The second phase is the execution phase where mutants are challenged by the test suite.
The last phase is the reporting phase where a report is generated based on the users preferences and data generated by PIT.
During the various stages we can extract characteristics by using PIT's plugin system.
\newline
PIT offers a plugin system in which developers can inject their own code in PIT\cite{pitestPlugin}.
There are two main types of plugins; a Mutation Result Listener and a Mutation interceptor\cite{pitestPlugin}.
A mutation result listener receives the details of analysed mutations as they arrive\cite{pitestPlugin}.
A Mutation interceptor is passed a complete list of all mutation that will be generated to each class before the mutation are challenged by tests\cite{pitestPlugin}.
The implementation of our experiment makes use of this plugins system.
\newline
We developed two plugins to extract characteristics.
The first plugin is of type Mutation interceptor.
It is provided a list of details per class. 
We can extract all characteristics but the Levensthein distance and the amount of tests a mutant is challenged by.
To calculate the Levensthein distance we need the byte code of the original code and the mutated code.
We generate the byte code of the original code based on the location provided in the list of details.
We make use of existing functionality in PIT for generating byte code.
The mutator is also provided in the list of details.
With the combination of location and mutator we can generate the byte code of the mutant.
With both pieces of code available we can calculate the Levenshtein distance between them.
\newline
The characteristics gathered until this phase of the mutation testing process are written, together with a unique identifier, to a \acrshort{csv} file.
\newline
The second plugin is a mutation result listener. 
This plugin gets passed a list of the results per mutant.
This list contains data about the mutant survival status.
It also contains data about the number of tests the mutant is challenged by.
We store this data together with the identifier to a different \acrshort{csv} file.
\newline
When the mutation testing process has finished we need to merge the characteristic gathered in the second plugin.
We add the characteristic; the number of tests the mutant is challenged by to the data file containing all the other characteristics.
We can merge the data because both files contain the same unique identifier per mutant.


\section{Levenshtein distance on Java byte code}
A mutant is a piece of code that differs in a predefined way from its parent.
Java source code compiles into Java byte code.
During the compilation of Java code certain context is abstracted away\cite{byteCodeEngineering}.
Optimisations are applied which also changes the Java byte code\cite{byteCodeEngineering}.
As a result the textual similarity between a Java code mutant and its parent is different from the similarity between a Java byte code mutant and its parent.
While the textual similarity may be different between the Java code and Java byte code the functionality remains the same.
Java byte code reflects more of the semantic nature of the source code than the source code itself does. 
PIT generates and executes mutants on byte code level\cite{pitestBytecode}. 
In other words PIT executes the unit tests of a source against the byte code of a mutant.
\newline
For our characteristic we will use the Levenshtein distance between a Java byte code mutant and its parent.
By calculating the distance on byte code we filter out the context that is present in Java code.
This gives us a Levenshtein distance that represents more of the semantic difference, between a mutant and parent, than calculating the distance for Java code.


\subsection{Levenshtein distance implementation}
write here that we use a memory efficient algorithm


\section{Hierarchical clustering}\todo{elaborate on why hierarchical clustering}
Clustering Levenshtein distances has been done before with hierarchical clustering\cite{Rajalingam2011HierarchicalStudy, Gothai2010PerformanceAlgorithms}. 
Hierarchical clustering is subdivided into agglomerative and divisive. 
The agglomerative hierarchical technique follows bottom up approach whereas divisive follows top-down approaches.
Hierarchical clustering uses different metrics which measures the the distance between two clusters and the linkage criteria\cite{Rajalingam2011HierarchicalStudy}. 
The linkage criteria specifies the dissimilarity in the sets as a function of the pair-wise distances of observations in those sets\cite{Rajalingam2011HierarchicalStudy}.
\newline
Research shows that the complete linkage outperforms the single linkage method\cite{Vijaya2019ComparativeClustering}.
The ward linkage and complete linkage methods perform the same when clusters are well separated\cite{Vijaya2019ComparativeClustering}.
However if the clusters overlap the ward linkage outperforms the complete linkage\cite{Vijaya2019ComparativeClustering}.
\newline
We identify all characteristics per mutant as a separate cluster.
Starting out with each mutant as a separate cluster we can use the agglomerative form of hierarchical clustering.
Since we cannot assume that our clusters are well separated we chose to use the ward linkage method for our clustering algorithm.
The agglormorative hierarchical clustering algorithm with ward linkage will cluster our mutants represented as Levenshtein distances.
\todo{write about implementation}

\section{Weighed mutation score}
Our hypothesis states that each mutants executed should be in the majority of mutants in its cluster. 
With a mutant executed from each cluster we can calculate a mutation score.
This mutation score is a weighed mutation score.
This weighed mutation score is the product of the result of a mutant(1 for killed and 0 for survived) and the amount of mutants in the cluster it represents.
The weighed mutation score is then comparable to the score of a full set as the total number of mutants will be the same.
\newline
For example, take a full set with a score of 75/100 killed mutants. \todo{example too much?}
This gives us a mutation score of 75\%. 
We then cluster the mutants in four clusters consisting of 12, 30, 38 and 20 mutants, respectively.
We randomly select four mutants of each cluster and execute them.
The mutants representing cluster one and four survive.
If we calculate the weighed score we get 68/100 which is 68\%.
We can then compare this to the score of a full set because the amount of mutants executed is the same: 75/100(75\%) and 68/100(68\%).



\end{document}